/**
 * PhpSocket - A JavaScript library for real-time WebSocket communication
 * This library provides a simple interface for connecting to a WebSocket server,
 * subscribing to channels, and handling events similar to Pusher.
 * 
 * @version 1.0.0
 * @license MIT
 * Copyright (c) 2025 Shahin Mosyan
 */ class PhpSocket{constructor(e,t={}){this.url=e,this.options={reconnect:!0,reconnectInterval:5e3,maxReconnectAttempts:10,enableHeartbeat:!0,heartbeatInterval:1e5,debug:!1,...t},this.ws=null,this.state="disconnected",this.reconnectAttempts=0,this.reconnectTimer=null,this.heartbeatTimer=null,this.lastHeartbeat=null,this.channels=new Map,this.globalEvents=new Map,this.pendingSubscriptions=new Set,this.messageQueue=[],this.connect=this.connect.bind(this),this.disconnect=this.disconnect.bind(this),this.reconnect=this.reconnect.bind(this),this.connect()}connect(){if("connecting"!==this.state&&"connected"!==this.state){this.state="connecting",this.log("Connecting to WebSocket...");try{this.ws=new WebSocket(this.url),this.setupEventHandlers()}catch(e){this.log("Connection failed:",e),this.handleConnectionError()}}}setupEventHandlers(){this.ws.onopen=()=>{this.state="connected",this.reconnectAttempts=0,this.log("✅ Connected to WebSocket"),this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.startHeartbeat(),this.processMessageQueue(),this.resubscribeChannels(),this.emit("connection:established")},this.ws.onmessage=e=>{try{let t=JSON.parse(e.data);this.handleMessage(t)}catch(s){this.log("Invalid message received:",s)}},this.ws.onclose=e=>{this.state="disconnected",this.log("\uD83D\uDD0C WebSocket connection closed",e.code,e.reason),this.stopHeartbeat(),this.emit("connection:closed",{code:e.code,reason:e.reason}),this.options.reconnect&&1e3!==e.code&&this.scheduleReconnect()},this.ws.onerror=e=>{this.log("❌ WebSocket error:",e),this.emit("connection:error",e)}}handleMessage(e){this.log("\uD83D\uDCE8 Received:",e);let{event:t,channel:s,data:n}=e;switch(t){case"subscription_succeeded":this.handleSubscriptionSucceeded(s);break;case"pong":this.handlePong();break;case"message":this.handleChannelMessage(s,n);break;default:s&&this.channels.has(s)?this.channels.get(s).trigger(t,n):this.emit(t,n)}}handleSubscriptionSucceeded(e){if(this.pendingSubscriptions.delete(e),this.channels.has(e)){let t=this.channels.get(e);t.subscribed=!0,t.trigger("subscription:succeeded")}this.log(`✅ Subscribed to channel: ${e}`)}handleChannelMessage(e,t){this.channels.has(e)&&this.channels.get(e).trigger("message",t)}handlePong(){this.lastHeartbeat=Date.now(),this.log("\uD83D\uDC93 Pong received")}scheduleReconnect(){if(this.reconnectAttempts>=this.options.maxReconnectAttempts){this.log("❌ Max reconnection attempts reached"),this.emit("connection:failed");return}this.state="reconnecting",this.reconnectAttempts++;let e=this.options.reconnectInterval*Math.pow(1.5,this.reconnectAttempts-1);this.log(`🔄 Reconnecting in ${e}ms (attempt ${this.reconnectAttempts})`),this.reconnectTimer=setTimeout(()=>{"reconnecting"===this.state&&this.connect()},e)}startHeartbeat(){this.options.enableHeartbeat&&(this.lastHeartbeat=Date.now(),this.heartbeatTimer=setInterval(()=>{if("connected"===this.state){this.send({event:"ping"});let e=Date.now();e-this.lastHeartbeat>2*this.options.heartbeatInterval&&(this.log("\uD83D\uDC80 Heartbeat timeout - closing connection"),this.ws.close())}},this.options.heartbeatInterval))}stopHeartbeat(){this.heartbeatTimer&&(clearInterval(this.heartbeatTimer),this.heartbeatTimer=null)}send(e){if("connected"===this.state&&this.ws.readyState===WebSocket.OPEN){let t=JSON.stringify(e);this.ws.send(t),this.log("\uD83D\uDCE4 Sent:",e)}else this.messageQueue.push(e),this.log("\uD83D\uDCE6 Queued message:",e)}processMessageQueue(){for(;this.messageQueue.length>0;){let e=this.messageQueue.shift();this.send(e)}}resubscribeChannels(){for(let[e,t]of this.channels)t.subscribed||(this.send({event:"subscribe",channel:e}),this.pendingSubscriptions.add(e))}subscribe(e){if(this.channels.has(e))return this.channels.get(e);let t=new Channel(e,this);return this.channels.set(e,t),this.send({event:"subscribe",channel:e}),this.pendingSubscriptions.add(e),t}unsubscribe(e){if(!this.channels.has(e))return;let t=this.channels.get(e);t.unsubscribe(),this.channels.delete(e),this.pendingSubscriptions.delete(e),this.send({event:"unsubscribe",channel:e}),this.log(`🚫 Unsubscribed from channel: ${e}`)}bind(e,t){return this.globalEvents.has(e)||this.globalEvents.set(e,[]),this.globalEvents.get(e).push(t),this}unbind(e,t=null){if(!this.globalEvents.has(e))return this;if(t){let s=this.globalEvents.get(e),n=s.indexOf(t);-1!==n&&s.splice(n,1)}else this.globalEvents.delete(e);return this}emit(e,t=null){this.globalEvents.has(e)&&this.globalEvents.get(e).forEach(e=>{try{e(t)}catch(s){this.log("Error in event callback:",s)}})}trigger(e,t,s){this.send({event:"trigger",channel:e,data:{event:t,data:s}})}disconnect(){this.options.reconnect=!1,this.state="disconnected",this.reconnectTimer&&(clearTimeout(this.reconnectTimer),this.reconnectTimer=null),this.stopHeartbeat(),this.channels.clear(),this.globalEvents.clear(),this.pendingSubscriptions.clear(),this.messageQueue=[],this.ws&&(this.ws.readyState===WebSocket.OPEN||this.ws.readyState===WebSocket.CONNECTING)&&this.ws.close(1e3,"Client disconnect"),this.log("\uD83D\uDD0C Disconnected")}reconnect(){this.disconnect(),this.options.reconnect=!0,this.reconnectAttempts=0,setTimeout(()=>this.connect(),100)}isConnected(){return"connected"===this.state&&this.ws&&this.ws.readyState===WebSocket.OPEN}getState(){return this.state}getStats(){return{state:this.state,channels:this.channels.size,reconnectAttempts:this.reconnectAttempts,queuedMessages:this.messageQueue.length,lastHeartbeat:this.lastHeartbeat}}log(...e){this.options.debug&&console.log("[PhpSocket]",...e)}}
 /**
 * Channel - Represents a WebSocket channel
 * This class provides methods to bind events, trigger events, and send messages on a specific channel.
 * It is used to manage communication on a specific channel within the WebSocket connection.
 * 
 * @version 1.0.0
 * @license MIT
 * @class
 * @property {string} name The name of the channel
 * @property {PhpSocket} socket The PhpSocket instance associated with this channel
 * Copyright (c) 2025 Shahin Mosyan
 */ class Channel{constructor(e,t){this.name=e,this.socket=t,this.subscribed=!1,this.events=new Map}bind(e,t){return this.events.has(e)||this.events.set(e,[]),this.events.get(e).push(t),this}unbind(e,t=null){if(!this.events.has(e))return this;if(t){let s=this.events.get(e),n=s.indexOf(t);-1!==n&&s.splice(n,1)}else this.events.delete(e);return this}trigger(e,t=null){return this.events.has(e)&&this.events.get(e).forEach(e=>{try{e(t)}catch(s){console.error("Error in channel event callback:",s)}}),this}send(e,t){return this.socket.trigger(this.name,e,t),this}unsubscribe(){return this.subscribed=!1,this.events.clear(),this}isSubscribed(){return this.subscribed}}"undefined"!=typeof window&&(window.PhpSocket=PhpSocket,window.Channel=Channel),"undefined"!=typeof module&&module.exports&&(module.exports={PhpSocket,Channel});